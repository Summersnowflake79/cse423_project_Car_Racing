import sys
import random
import math

from OpenGL.GL import *
from OpenGL.GLUT import *
from OpenGL.GLU import *

window_width = 800
window_height = 800

ground_color = (0.2, 0.6, 0.2)
track_color = (0.5, 0.5, 0.5)

cones = []
trees = []
flowers = []

camera_view = 0

car_x = 15.0
car_z = -5.0
car_angle = 0.0
car_speed = 0.05

countdown_state = 0
countdown_start_time = 0

def init_gl():
    glClearColor(0.8, 0.9, 1.0, 1.0)
    glEnable(GL_DEPTH_TEST)

def draw_ground():
    glColor3f(*ground_color)
    glBegin(GL_QUADS)
    glVertex3f(-50.0, 0.0, -50.0)
    glVertex3f(-50.0, 0.0, 50.0)
    glVertex3f(50.0, 0.0, 50.0)
    glVertex3f(50.0, 0.0, -50.0)
    glEnd()

def draw_racetrack():
    glColor3f(*track_color)

    outer_x_min = -20.0
    outer_x_max = 20.0
    outer_z_min = -30.0
    outer_z_max = 30.0

    inner_x_min = -10.0
    inner_x_max = 10.0
    inner_z_min = -22.0
    inner_z_max = 22.0
    
    glBegin(GL_QUADS)
    glVertex3f(inner_x_min, 0.01, inner_z_max)
    glVertex3f(inner_x_max, 0.01, inner_z_max)
    glVertex3f(inner_x_max, 0.01, outer_z_max)
    glVertex3f(inner_x_min, 0.01, outer_z_max)
    glEnd()

    glBegin(GL_QUADS)
    glVertex3f(inner_x_min, 0.01, outer_z_min)
    glVertex3f(inner_x_max, 0.01, outer_z_min)
    glVertex3f(inner_x_max, 0.01, inner_z_min)
    glVertex3f(inner_x_min, 0.01, inner_z_min)
    glEnd()

    glBegin(GL_QUADS)
    glVertex3f(outer_x_min, 0.01, inner_z_min)
    glVertex3f(inner_x_min, 0.01, inner_z_min)
    glVertex3f(inner_x_min, 0.01, inner_z_max)
    glVertex3f(outer_x_min, 0.01, inner_z_max)
    glEnd()

    glBegin(GL_QUADS)
    glVertex3f(inner_x_max, 0.01, inner_z_min)
    glVertex3f(outer_x_max, 0.01, inner_z_min)
    glVertex3f(outer_x_max, 0.01, inner_z_max)
    glVertex3f(inner_x_max, 0.01, inner_z_max)
    glEnd()
    
    glBegin(GL_QUADS)
    glVertex3f(inner_x_max, 0.01, inner_z_max)
    glVertex3f(outer_x_max, 0.01, inner_z_max)
    glVertex3f(outer_x_max, 0.01, outer_z_max)
    glVertex3f(inner_x_max, 0.01, outer_z_max)
    glEnd()

    glBegin(GL_QUADS)
    glVertex3f(outer_x_min, 0.01, inner_z_max)
    glVertex3f(inner_x_min, 0.01, inner_z_max)
    glVertex3f(inner_x_min, 0.01, outer_z_max)
    glVertex3f(outer_x_min, 0.01, outer_z_max)
    glEnd()

    glBegin(GL_QUADS)
    glVertex3f(outer_x_min, 0.01, outer_z_min)
    glVertex3f(inner_x_min, 0.01, outer_z_min)
    glVertex3f(inner_x_min, 0.01, inner_z_min)
    glVertex3f(outer_x_min, 0.01, inner_z_min)
    glEnd()

    glBegin(GL_QUADS)
    glVertex3f(inner_x_max, 0.01, outer_z_min)
    glVertex3f(outer_x_max, 0.01, outer_z_min)
    glVertex3f(outer_x_max, 0.01, inner_z_min)
    glVertex3f(inner_x_max, 0.01, inner_z_min)
    glEnd()

    start_line_z_pos = -5.0
    line_width_z = 2.0
    square_side = 1.0

    num_squares_x = int((outer_x_max - inner_x_max) / square_side)
    num_squares_z = int(line_width_z / square_side)

    for j in range(num_squares_z):
        for i in range(num_squares_x):
            if (i + j) % 2 == 0:
                glColor3f(1.0, 1.0, 1.0)
            else:
                glColor3f(0.0, 0.0, 0.0)
            
            x_pos = inner_x_max + (i * square_side)
            z_pos = start_line_z_pos - (line_width_z / 2.0) + (j * square_side)

            glBegin(GL_QUADS)
            glVertex3f(x_pos, 0.02, z_pos)
            glVertex3f(x_pos + square_side, 0.02, z_pos)
            glVertex3f(x_pos + square_side, 0.02, z_pos + square_side)
            glVertex3f(x_pos, 0.02, z_pos + square_side)
            glEnd()
    
def draw_car(x, z, r, g, b, rotation):
    glPushMatrix()
    
    glTranslatef(x, 0.3, z)
    glRotatef(rotation, 0.0, 1.0, 0.0)

    glColor3f(r, g, b)
    glPushMatrix()
    glScalef(0.8, 0.4, 1.6)
    glutSolidCube(1.0)
    glPopMatrix()
    
    glColor3f(0.1, 0.1, 0.1)
    wheel_size = 0.15
    
    glPushMatrix()
    glTranslatef(0.4, -0.2, 0.6)
    glutSolidCube(wheel_size)
    glPopMatrix()
    
    glPushMatrix()
    glTranslatef(-0.4, -0.2, 0.6)
    glutSolidCube(wheel_size)
    glPopMatrix()

    glPushMatrix()
    glTranslatef(0.4, -0.2, -0.6)
    glutSolidCube(wheel_size)
    glPopMatrix()
    
    glPushMatrix()
    glTranslatef(-0.4, -0.2, -0.6)
    glutSolidCube(wheel_size)
    glPopMatrix()

    glPopMatrix()

def draw_cone(x, z):
    glPushMatrix()
    glTranslatef(x, 0.25, z)
    glRotatef(-90, 1.0, 0.0, 0.0)
    
    glColor3f(1.0, 0.6, 0.0)
    glutSolidCone(0.5, 1.0, 10, 10)
    
    glPopMatrix()

def draw_tree(x, z):
    glPushMatrix()
    glTranslatef(x, 0.0, z)
    
    glColor3f(0.5, 0.3, 0.1)
    glPushMatrix()
    glRotatef(-90.0, 1.0, 0.0, 0.0)
    quadric = gluNewQuadric()
    gluCylinder(quadric, 0.5, 0.5, 2.0, 32, 32)
    glPopMatrix()
    
    glColor3f(0.0, 0.5, 0.0)
    glPushMatrix()
    glTranslatef(0.0, 2.0, 0.0)
    glutSolidSphere(1.5, 32, 32)
    glPopMatrix()

    glPopMatrix()

def draw_lake():
    glPushMatrix()
    glColor3f(0.6, 0.8, 1.0)
    glTranslatef(0.0, 0.01, 0.0)
    glRotatef(-90.0, 1.0, 0.0, 0.0)
    
    quadric = gluNewQuadric()
    gluDisk(quadric, 0.0, 8.0, 50, 1) 
    gluDeleteQuadric(quadric)
    
    glPopMatrix()

def draw_flowers():
    for x, z, r, g, b in flowers:
        glPushMatrix()
        glColor3f(r, g, b)
        glTranslatef(x, 0.05, z)
        glutSolidSphere(0.15, 10, 10)
        glPopMatrix()

def draw_text(x, y, text, font=GLUT_BITMAP_TIMES_ROMAN_24):
    glMatrixMode(GL_PROJECTION)
    glPushMatrix()
    glLoadIdentity()
    gluOrtho2D(0, window_width, 0, window_height)

    glMatrixMode(GL_MODELVIEW)
    glPushMatrix()
    glLoadIdentity()
    
    glColor3f(1.0, 1.0, 1.0)

    glRasterPos2f(x, y)
    
    for ch in text:
        glutBitmapCharacter(font, ord(ch))
    
    glPopMatrix()
    glMatrixMode(GL_PROJECTION)
    glPopMatrix()
    glMatrixMode(GL_MODELVIEW)

def is_on_racetrack(x, z):
    outer_x_min, outer_x_max = -20.0, 20.0
    outer_z_min, outer_z_max = -30.0, 30.0
    inner_x_min, inner_x_max = -10.0, 10.0
    inner_z_min, inner_z_max = -22.0, 22.0
    
    is_on_outer_rect = (outer_x_min <= x <= outer_x_max) and (outer_z_min <= z <= outer_z_max)
    is_on_inner_rect = (inner_x_min <= x <= inner_x_max) and (inner_z_min <= z <= inner_z_max)

    return is_on_outer_rect and not is_on_inner_rect

def check_cone_collision(car_x, car_z):
    for cone_x, cone_z in cones:
        distance = math.sqrt((car_x - cone_x)**2 + (car_z - cone_z)**2)
        car_radius = 0.5
        cone_radius = 0.5
        if distance < car_radius + cone_radius:
            return True
    return False

def display():
    global car_x, car_z, car_angle

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    glLoadIdentity()
    
    if camera_view == 0:
        gluLookAt(0.0, 40.0, 60.0,
                  0.0, 0.0, 0.0,
                  0.0, 1.0, 0.0)
    elif camera_view == 1:
        camera_x = car_x - 5.0 * math.sin(math.radians(car_angle))
        camera_y = 3.0
        camera_z = car_z - 5.0 * math.cos(math.radians(car_angle))
        
        gluLookAt(camera_x, camera_y, camera_z,
                  car_x, 0.0, car_z,
                  0.0, 1.0, 0.0)
    elif camera_view == 2:
        camera_x = car_x + 1.5 * math.sin(math.radians(car_angle))
        camera_y = 0.5
        camera_z = car_z + 1.5 * math.cos(math.radians(car_angle))
        
        look_at_x = camera_x + 5.0 * math.sin(math.radians(car_angle))
        look_at_y = camera_y
        look_at_z = camera_z + 5.0 * math.cos(math.radians(car_angle))
        
        gluLookAt(camera_x, camera_y, camera_z,
                  look_at_x, look_at_y, look_at_z,
                  0.0, 1.0, 0.0)

    draw_ground()
    draw_racetrack()
    draw_lake()
    draw_flowers()
    
    draw_car(car_x, car_z, 1.0, 0.0, 0.0, car_angle)

    for x, z in cones:
        draw_cone(x, z)
        
    for x, z in trees:
        draw_tree(x, z)
    
    if countdown_state > 0:
        draw_text(window_width / 2 - 10, window_height / 2, str(countdown_state))

    glutSwapBuffers()

def reshape(width, height):
    global window_width, window_height
    window_width = width
    window_height = height
    if height == 0:
        height = 1

    glViewport(0, 0, width, height)
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    gluPerspective(45.0, float(width) / float(height), 0.1, 100.0)
    glMatrixMode(GL_MODELVIEW)

def keyboard(key, x, y):
    global camera_view, car_speed, car_angle, countdown_state, car_x, car_z
    if key == b'q' or key == b'\x1b':
        sys.exit()
    elif key == b'c':
        camera_view = (camera_view + 1) % 3
        if camera_view in [1, 2]:
            countdown_state = 3
            car_speed = 0.0
            car_x = 15.0
            car_z = -5.0
            car_angle = 0.0
            global countdown_start_time
            countdown_start_time = glutGet(GLUT_ELAPSED_TIME)
        else:
            countdown_state = 0
        glutPostRedisplay()
    
    if countdown_state == 0 and camera_view in [1, 2]:
        if key == b'w':
            car_speed += 0.1
        elif key == b's':
            car_speed -= 0.1
        elif key == b'a':
            car_angle += 5.0
        elif key == b'd':
            car_angle -= 5.0

def update(value):
    global car_x, car_z, car_speed, car_angle, countdown_state, countdown_start_time

    if countdown_state > 0:
        current_time = glutGet(GLUT_ELAPSED_TIME)
        elapsed_time = current_time - countdown_start_time
        if elapsed_time > 3000:
            countdown_state = 0
        elif elapsed_time > 2000:
            countdown_state = 1
        elif elapsed_time > 1000:
            countdown_state = 2
    
    if countdown_state == 0:
        potential_x = car_x + car_speed * math.sin(math.radians(car_angle))
        potential_z = car_z + car_speed * math.cos(math.radians(car_angle))

        if is_on_racetrack(potential_x, potential_z) and not check_cone_collision(potential_x, potential_z):
            car_x = potential_x
            car_z = potential_z
        else:
            car_speed = 0

        car_speed *= 0.95
    
    glutPostRedisplay()
    
    glutTimerFunc(10, update, 0)

def generate_cones():
    cones.append((-17.0, -15.0))
    cones.append((-13.0, -5.0))
    cones.append((-17.0, 5.0))
    cones.append((-13.0, 15.0))
    cones.append((-17.0, 20.0))
            
def generate_trees(num_trees):
    ground_bounds = (-50.0, 50.0)
    
    lake_center = (0.0, 0.0)
    lake_radius = 8.0

    outer_x_min, outer_x_max = -20.0, 20.0
    outer_z_min, outer_z_max = -30.0, 30.0
    
    count = 0
    while count < num_trees:
        x = random.uniform(ground_bounds[0], ground_bounds[1])
        z = random.uniform(ground_bounds[0], ground_bounds[1])
        
        if (outer_x_min <= x <= outer_x_max) and (outer_z_min <= z <= outer_z_max):
            continue

        distance_from_lake_center = math.sqrt((x - lake_center[0])**2 + (z - lake_center[1])**2)
        if distance_from_lake_center < lake_radius:
            continue
        
        trees.append((x, z))
        count += 1

def generate_flowers(num_flowers):
    inner_x_min, inner_x_max = -10.0, 10.0
    inner_z_min, inner_z_max = -22.0, 22.0
    
    lake_center = (0.0, 0.0)
    lake_radius = 8.0
    
    count = 0
    while count < num_flowers:
        x = random.uniform(inner_x_min, inner_x_max)
        z = random.uniform(inner_z_min, inner_z_max)
        
        distance_from_lake_center = math.sqrt((x - lake_center[0])**2 + (z - lake_center[1])**2)
        if distance_from_lake_center < lake_radius + 0.5:
            continue
            
        r = random.random()
        g = random.random()
        b = random.random()
        flowers.append((x, z, r, g, b))
        count += 1

def main():
    glutInit(sys.argv)
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH)
    glutInitWindowSize(window_width, window_height)
    glutCreateWindow(b"OpenGL Racetrack")

    init_gl()
    generate_cones()
    generate_trees(200)
    generate_flowers(200)
    
    glutTimerFunc(10, update, 0)

    glutDisplayFunc(display)
    glutReshapeFunc(reshape)
    glutKeyboardFunc(keyboard)

    glutMainLoop()

if __name__ == "__main__":
    main()
